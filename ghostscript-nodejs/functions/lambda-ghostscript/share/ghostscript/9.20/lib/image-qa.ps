%!PS
% Copyright (C) 2001-2012 Artifex Software, Inc.
% All Rights Reserved.
%
% This software is provided AS-IS with no warranty, either express or
% implied.
%
% This software is distributed under license and may not be copied,
% modified or distributed except as expressly authorized under the terms
% of the license contained in the file LICENSE in this distribution.
%
% Refer to licensing information at http://www.artifex.com or contact
% Artifex Software, Inc.,  7 Mt. Lassen Drive - Suite A-134, San Rafael,
% CA  94903, U.S.A., +1(415)492-9861, for further information.
%
%
% Tests for the image operators

% Specifications for Image operator testing.
%
% 1.  All 8 standard orientations (0, 90, 180, 270 degree rotations with
%     and without reflection); ditto those orientations perturbed by +/-
%     10 degrees, and by 45 degrees.
%
%     Enough space is provided around images on a test page to allow
%     these permutations to use the same page layout. This will make
%     test page construction easier and simplify page checking.
%
% 2.  All 9 image types (ImageType 1 mask, ImageType 1 opaque,
%     ImageType 3 with all 3 InterleaveTypes and with unequal scaling
%     for InterleaveType 2 and 3, ImageType 4 with both range and
%     single-point matching).
%
% 3.  DeviceGray, DeviceRGB, and DeviceN color, both direct and Indexed.
%     Indexed color will use the common pallete size of 256 colors.
%
% 4.  For simple masks, both colored and uncolored Patterns.
%
% 5.  CombineWithColor true and false; several different colors for the
%     true case (including black, white, other solid colors, halftones,
%     and patterns).
%
% 6.  Source transparency true and false.
%
% 7.  Texture transparency true and false.
%
% 8.  Different RasterOp values.
%
% 9.  For ImageType 4, different color keys (out-of-range, specific
%     color other than white, range without white).
%
% 10. String, file, and procedure data sources; for multi-component
%     color spaces, MultipleDataSources = true. This is tested by
%     constructing string data sources that are used as input to
%     SubFileDecode filter to create a filetype data source. These
%     filters are read into scratch strings for the procedure data
%     source case. The procedure data source scratch string length
%     does not match the raster width, and the width x height is
%     not an integer multiple of the string length.
%
%     Also for the File case, the number of bytes consumed is
%     checked after the image operator to verify that the exact
%     amount of data is used. This is particularly important when
%     the currentfile is used as a source (possibly through a
%     filter.
%
%     Image bytes per line are < 500 bytes to exercise direct and
%     buffer copy gs_image_next_planes mode with the default stream
%     buffer size of 512 bytes. Procedure string size is greater
%     than the image bytes per line for the same reason (sM and sD).
%
%     Total string size is kept below 65535.

/WidthRGB	83 def
/HeightRGB	89 def

%
% 11. Banded and non-banded rendering. This can be tested by running
%     test files throuch with different page device parameters to
%     force banding vs. page mode.
%
% -------------------------------------------------------------------------
%
% Testing the RasterOp-related functions (5/6/7/8) is not necessary at this
% time.  They are well isolated logically.
%
% Testing orientation (1) and color masking (9) would be a good idea at some
% point, because this code has broken many times in the past and has had a
% long bug tail.
%
% The really important things to test are 2 (image type), 3/4 (color space --
% but only with regard to number of components, plus DeviceN and simple masks
% with a Pattern, which exercise special control paths), 10 (data source),
% and 11 (banding modes).
%
% ==========================================================================

%
% Procedure to generate test mask data
%
% WM and HM must be defined prior to invocation
%     MaskGen -
%
% The mask data is stored into a string named /MaskData
%
% The mask consists of a "target". Bits past width WM are
% filled with 1's to make sure that pad bits are ignored.
%
/MaskGen {
  /H8 HM 8 div def
  /X0 WM 2 div def
  /Y0 HM 2 div def
  /WB WM 7 add 8 div cvi def
  /MaskData WB HM mul string def
  /MB [ 128 64 32 16 8 4 2 1 ] def
  0 1 HM 1 sub {
    /Y exch def
    0 1 WB 1 sub {
      /B exch def	% byte within the row
      /C B Y WB mul add def
      /P 0 def
      0 1 7 {
        /b exch def	% bit within the character
        /X b B 8 mul add def
        X WM lt
          { X Y eq
            X HM 1 sub Y sub eq or
            Y Y0 gt X X0 sub abs 2 le and or
            X X0 sub WM div dup mul Y Y0 sub HM div dup mul add sqrt 9 mul cvi 2 mod 1 eq or
          }
          { true }	% pad bits are always set
        ifelse
        % stack: true if pixel is set
        {
          MB b get P or /P exch def
        } if
      } for % Bits within a byte
      MaskData C P put
    } for % Bytes within the row
  } for % Rows in the mask
} bind def			% MaskGen

%
% WM and HM must be defined prior to invocation
%     BPC MaskGenBPC -
%
% The mask data is stored into a string named /MaskData
%
% The mask consists of a "target". BPC is the size of the elements
% in the MaskData string (must be 4, 8 or 12)
%
/MaskGenBPC {
  /BPC exch def
  /X0 WM 2 div def
  /Y0 HM 2 div def
  /WB WM BPC mul 7 add 8 div cvi def		% Width in Bytes
  /MaskData WB HM mul string def
  0 1 HM 1 sub {
    /Y exch def
    0 1 WM 1 sub {
      /X exch def
      MaskData				% Target string
      X Y eq
      X HM 1 sub Y sub eq or
      Y Y0 gt X X0 sub abs 2 le and or
      X X0 sub WM div dup mul Y Y0 sub HM div dup mul add sqrt 9 mul cvi 2 mod 1 eq or
      X BPC mul 8 div Y WB mul add exch
      [
        { }						% BPC = 0
        { { 1 } { 0 } ifelse put4bit }			% BPC = 4
        { { 255 } { 0 } ifelse exch cvi exch put }	% BPC = 8
        { { 1 } { 0 } ifelse put12bit }			% BPC = 12
      ] BPC 4 div cvi get exec
    } for
  } for % Rows in the mask
} bind def

% -----------------------------------------------------------------------

% Procedure to generate image data
%
% WD and HD must be defined prior to invocation
%    { proc } ImageGen -
%
% The procedure is called once for each pixel
% Local definitions are R, G, B, X and Y

% Example: Generate RGB Chunky pixel data (single data source) BPC = 8
%       /WD WidthRGB def
%       /HD HeightRGB def
%       /RGBData WD HD mul 3 mul string def
% 	{ X Y WD mul add 3 mul RGBData
% 	  dup 2 index R 255 mul cvi put
% 	  dup 2 index 1 add G 255 mul cvi put
% 	  exch 2 add B 255 mul cvi put
% 	} ImageGen

/ImageGen {
  gsave
  0 1 HD 1 sub {
    /Y exch def
    0 1 WD 1 sub {
      /X exch def
      /D X WD 2 div sub WD div dup mul Y HD 2 div sub HD div dup mul add sqrt def
      /D D .6 div def
      /A X WD 2 div sub Y HD 2 div sub atan 360 div def
      A                               % Hue
      .7 D .3 sub .60 div sub  % Saturation
      dup 0.05 lt
        { .95 D .8 sub 3 mul sub 3 mul cvi 3 div sqrt } % Level once Saturation < 0
        { .7 D .25 sub .75 div add }  % Level inside
      ifelse
      X WD 2 div gt Y HD 2 div sub abs 2 le and { pop 0 } if   % asymmetric marker
      sethsbcolor
      currentrgbcolor /B exch def /G exch def /R exch def
      dup exec
    } for
  } for
  pop		% discard the procedure
  grestore
} bind def

% -----------------------------------------------------------------------
%
% Procedures for ImageMatrix creation
/IMLRTB { [ WD 0 0 HD neg 0 HD ] } def
/IMLRBT { [ WD 0 0 HD 0 0 ] } def
/IMRLTB { [ WD neg 0 0 HD neg WD HD ] } def
/IMRLBT { [ WD neg 0 0 HD WD 0 ] } def
% -----------------------------------------------------------------------
%
% Procedure to make invocation of image operators more concise
%
% YY, SX, SY, WD and HD should be defined prior to invocation
% X matrix source decode DoImageMask -
%
/DoImageMask {
  gsave
  /D exch def
  /S exch def
  /M exch def
  /XX 1 index def
  YY translate SX SY scale
  0 setlinewidth 0 0 moveto 1 0 lineto 1 1 lineto 0 1 lineto 0 0 lineto stroke
  .5 .5 translate
  IR rotate
  -.5 -.5 translate
  <<
  /ImageType		1
  /Width		WM
  /Height		HM
  /ImageMatrix		M
  /MultipleDataSources	false
  /DataSource		S
  /Decode		D
  /BitsPerComponent	1
  >>
  imagemask
  grestore
} bind def

% YY, SX, SY, WD and HD should be defined prior to invocation
% X Y BPC matrix source multi decode DoImage1 -
%
/DoImage1 {
  gsave
  CSpace setcolorspace
  /D exch def
  /MS exch def
  /S exch def		% May be an array of sources
  /M exch def
  /BPC exch def
  /XX 1 index def
  YY translate SX SY scale
  0 setlinewidth 0 0 moveto 1 0 lineto 1 1 lineto 0 1 lineto 0 0 lineto stroke
  .5 .5 translate
  IR rotate
  -.5 -.5 translate
  <<
  /ImageType		1
  /Width		WD
  /Height		HD
  /ImageMatrix		M
  /MultipleDataSources	MS
  /DataSource		S
  /BitsPerComponent	BPC
  /Decode		D
  >>
  image
  grestore
} bind def

% YY, SX, SY, WD and HD should be defined prior to invocation
% X Y BPC matrix source multi decode MaskColor DoImage4 -
%
/DoImage4 {
  gsave
  CSpace setcolorspace
  /MC exch def
  /D exch def
  /MS exch def
  /S exch def		% May be an array of sources
  /M exch def
  /BPC exch def
  /XX 1 index def
  YY translate SX SY scale
  0 setlinewidth 0 0 moveto 1 0 lineto 1 1 lineto 0 1 lineto 0 0 lineto stroke
  .5 .5 translate
  IR rotate
  -.5 -.5 translate
  <<
  /ImageType		4
  /Width		WD
  /Height		HD
  /ImageMatrix		M
  /MultipleDataSources	MS
  /DataSource		S
  /BitsPerComponent	BPC
  /Decode		D
  /MaskColor		MC
  >>
  image
  grestore
} bind def

% YY, SX, SY, W, HD (Data) WM, HM (Mask) should be defined prior to invocation
%                                                   (IT is InterleaveType)
% X Y BPC matrix source multi MaskDecode DataDecode IT DoImage3 -
%
/DoImage3 {
  gsave
  CSpace setcolorspace
  /IT exch def
  /DD exch def
  /DM exch def
  /MS exch def
  /S exch def		% May be an array of sources - For InterleaveType 3
                        % S[0] is the Mask DataSource
  /M exch def
  /BPC exch def
  /XX 1 index def
  YY translate SX SY scale
  0 setlinewidth 0 0 moveto 1 0 lineto 1 1 lineto 0 1 lineto 0 0 lineto stroke
  .5 .5 translate
  IR rotate
  -.5 -.5 translate
  /DataImage
  <<
  /ImageType		1
  /Width		WD
  /Height		HD
  /ImageMatrix		M
  /MultipleDataSources	MS
  /DataSource		IT 3 ne { S } { S 1 get exec } ifelse
  /BitsPerComponent	BPC
  /Decode		DD
  >>
  def
  /MaskImage
  <<
  /ImageType		1
  /Width		WM
  /Height		HM
  /ImageMatrix		% construct the mask matrix using signs from the DataImage matrix
                        /M0 M 0 get WD abs div cvi def
                        /M3 M 3 get HD abs div cvi def
                        /M4 M 4 get WD abs div cvi def
                        /M5 M 5 get HD abs div cvi def
                        [ WM M0 mul 0 0 HM M3 mul WM M4 mul HM M5 mul ]
  IT 3 eq {
    /DataSource		S 0 get exec	% DataSource only allowed for InterleaveType 3
  } if
  /BitsPerComponent	IT 1 eq { BPC } { 1 } ifelse
  /Decode		DM
  >>
  def
  <<
  /ImageType		3
  /DataDict		DataImage
  /MaskDict		MaskImage
  /InterleaveType	IT
  >>
  image
  grestore
} bind def

% -----------------------------------------------------------------------
%
/Helvetica-Bold findfont 20 scalefont /TitleFont exch def

/FontSize 10 def
/Helvetica-Narrow findfont FontSize scalefont /LegendFont exch def

/blockshow {	% like "show" but '\n' causes new-line
  dup = flush	%DEBUG
  currentpoint /showY exch def /showX exch def
  {
    dup 10 ne
    { 1 string dup 0 4 -1 roll put show }
    { pop showX showY FontSize sub dup /showY exch def moveto }
    ifelse
  } forall
} bind def

/TX 013 def	% Title left X
/SX 036 def
/XA 060 def
/XB XA SX 1.5 mul add def
/XC XA SX 3.0 mul add def
/XD XA SX 4.5 mul add def
/XE XA SX 6.0 mul add def
/XF XA SX 7.5 mul add def
/XG XA SX 9.0 mul add def
/XH XA SX 10.5 mul add def
/XI XA SX 12.0 mul add def
/XJ XA SX 13.5 mul add def

/BY 036 def	% Bottom Title Top line
/SY 037 def
/YA 050 def
/YB YA SY 1.8 mul add def
/YC YA SY 3.6 mul add def
/YD YA SY 5.4 mul add def
/YE YA SY 7.2 mul add def
/YF YA SY 9.0 mul add def
/YG YA SY 10.8 mul add def
/YH YA SY 12.6 mul add def
/YI YA SY 14.4 mul add def
/YJ YA SY 16.2 mul add def
/YK YA SY 18.0 mul add def

% -----------------------------------------------------------------------
%
%     Utility procedures to support storing 4 and 12 bit elements in
%     strings.
%
%     <string> <index> <value> put##bit -
%
%     <index> will have a fractional part ( .5 ) if the element
%     starts on a 4-bit boundary.
%
%     <value> is between 0 and 1 and is scaled 0 to 15 (4bit) or
%     0 to 4095 (12 bit)

/put4bit {
  15 mul cvi
  exch dup cvi dup 3 1 roll eq 3 -1 roll exch
  { % integer index means high nibble.
    16 mul put
  }
  { % low nibble -- combine with high nibble
    2 index 2 index get or put
  }
  ifelse
} bind def

/put12bit {
  1 index cvi /I exch def
  2 index /S exch def
  4095 mul cvi
  exch dup dup cvi eq
  { % integer index means high byte is aligned
    cvi exch 3 copy 16 div cvi put
    exch 1 add exch 15 and 16 mul put
  }
  { % low nibble -- combine with high nibble
    cvi exch 3 copy 2 index 2 index get exch 256 div cvi or put
    255 and exch 1 add exch put
  }
  ifelse
} bind def

% -----------------------------------------------------------------------
%
%     Procedures to use generated string data as procedure or files

/WD WidthRGB def
/HD HeightRGB def

/sM WidthRGB 2 mul 1 sub string def	% long enough to hold more than one mask line
/sD WidthRGB 7 mul 1 sub string def	% long enough to hold more than one 12 bit RGB line
                                % worst case is 12bit ImageType3 InterleaveType 1 == 48 bits

/MaskDProc {
  /FM MaskData dup length () /SubFileDecode filter def
  { { FM sM readstring pop } }
} bind def

/FileTailString (12345) def		% Marker string to check file data usage

/AppendFileTail {    %  <string> AppendFileTail <string_with_tail> <original_length>
  dup length FileTailString length add string
  dup 0 3 index putinterval
  dup 2 index length FileTailString putinterval
  exch length
} bind def

/MaskDFile {
  MaskData dup length () /SubFileDecode filter
  /MDF 1 index def
} bind def

/RGBDProc {
  /FD RGBData dup length () /SubFileDecode filter def
  { { FD sD readstring pop } }
} bind def

/RGBDFile {
  RGBData dup length () /SubFileDecode filter
  /RGBDF 1 index def
} bind def

/sR WidthRGB 2 mul 1 sub string def	% long enough to hold more than one line of 12 bit data
/sG WidthRGB 2 mul 1 sub string def
/sB WidthRGB 2 mul 1 sub string def

/RDProc {
  /FR RData dup length () /SubFileDecode filter def
  { FR sR readstring pop }
} bind def

/GDProc {
  /FG GData dup length () /SubFileDecode filter def
  { FG sG readstring pop }
} bind def

/BDProc {
  /FB BData dup length () /SubFileDecode filter def
  { FB sB readstring pop }
} bind def

/RDFile {
  RData dup length () /SubFileDecode filter
  /RDF 1 index def
} bind def

/GDFile {
  GData dup length () /SubFileDecode filter
  /GDF 1 index def
} bind def

/BDFile {
  BData dup length () /SubFileDecode filter
  /BDF 1 index def
} bind def

% -----------------------------------------------------------------------
%
%  Procedure to handle fileposition. Ghostscript has a private
%  operator .fileposition that works when fileposition does not
%
%    <file> tryfilepos
% 	Returns:	fileposition true	if successful
%			0 false			if not
/tryfilepos {
  /.fileposition where
    { pop /.fileposition load }	% most likely to succeed
    { /fileposition load }
  ifelse
  stopped
    { pop 0 false }
    { true }
  ifelse
} bind def

% -----------------------------------------------------------------------
%
% Procedure to provide =only operator if not present. Suggested
% by Alex Cherepanov to use =print operator present on some Adobe
% implementations.
/=only where
  { pop }
  { /=print where { pop /=print load } { /print load } ifelse
    /=only exch def
  }
ifelse

% -----------------------------------------------------------------------
%
%  Procedure to make sure that the file is at the EOF.
%  added above (string == FileTailString.
%
%  If not, it will mark the image area with a red "F"
%
%    <string> <title> <file> CheckFileTail -	XX is the horizontal position
%						YY is the vertical position
%						SX,SY determine size of "F" if fail
/CheckFileTail {
  dup
  status not dup	% status false says no longer valid
  { (Unexpected EOF: XX,YY=) print XX =only (,) print YY = false }
  { 1 index tryfilepos not exch 5 index length ne or dup
    { 3 index print ( fileposition = ) print
      2 index tryfilepos pop =only
      ( doesn't match expected = ) print 4 index length = flush
    }
    if
  }
  ifelse
  or
  {
    gsave .8 0 0 setrgbcolor
    SX 4 div setlinewidth
    XX YY moveto 0 SY rlineto SX 0 rlineto stroke
    XX YY SY .5 mul add moveto SX .5 mul 0 rlineto stroke
    grestore
  }
  if
  pop pop pop
} bind def

/CSpaceName {		%    - CSpaceName <string>
  CSpace dup type /arraytype eq { 0 get } if
  15 string cvs
} bind def
% -----------------------------------------------------------------------
%
% tests

/CheckImage {

  /IR 0 def
  /CSpace /DeviceRGB def

  % Use an unusual (unpleasant?) underlying color
  .6 .95 .4 setrgbcolor clippath fill

  0 0 0 setrgbcolor
  TitleFont setfont
  200 760 moveto (Image Type 3 Tests) show
  200 740 moveto (Rotation Angle = ) show IR 3 string cvs show
  170 720 moveto (Colorspace = ) show CSpaceName show
  LegendFont setfont

  .4 .1 .7 setrgbcolor	% contrasting color for stencil masking
  /SX SX 2 mul def /SY SY 2 mul def
  /YY 780 SY sub def
  MaskGen
  TX IMLRTB MaskData  [1 0] DoImageMask

  /RGBData WD HD mul 3 mul string def
  { X Y WD mul add 3 mul RGBData
    dup 2 index R 255 mul cvi put
    dup 2 index 1 add G 255 mul cvi put
    exch 2 add B 255 mul cvi put
  } ImageGen

  % X BPC matrix source  multi  decode
   XI  8  IMLRTB RGBData false  [0 1 0 1 0 1]  DoImage1
  /SX SX 2 div def /SY SY 2 div def

  showpage
} def

% -----------------------------------------------------------------------
%
% Type 1 and Type 4 Tests

%	/CSpace and /IR are defined in order to generate various pages
/T1T4Tests {	%

  % Use an unusual (unpleasant?) underlying color
  .6 .95 .4 setrgbcolor clippath fill
  0 0 0 setrgbcolor

  TitleFont setfont
  120 760 moveto (Image Type 1 and ImageType 4 Tests) show
  200 740 moveto (Rotation Angle = ) show IR 3 string cvs show
  170 720 moveto (Colorspace = ) show CSpaceName show
  LegendFont setfont

  XA BY moveto (Decode\nInverted) blockshow
  XB BY moveto (  IMLRTB\nDS=string) blockshow
  XC BY moveto (  IMLRBT\nDS=string) blockshow
  XD BY moveto (  IMRLTB\nDS=string) blockshow
  XE BY moveto (  IMRLBT\nDS=string) blockshow
  XF BY moveto (IMLRTB\nDS=proc) blockshow
  XG BY moveto (IMLRTB\nDS=file) blockshow
  XH BY moveto (   Multi\nDS=string) blockshow
  XI BY moveto (  Multi\nDS=proc) blockshow
  XJ BY moveto (  Multi\nDS=file) blockshow

  .4 .1 .7 setrgbcolor	% contrasting color for stencil masking

  /WM WD def
  /HM HD def
  /SX SX 2 mul def /SY SY 2 mul def
  /YY 780 SY sub def
  MaskGen
  TX IMLRTB MaskData  [1 0] DoImageMask

  /RGBData WD HD mul 3 mul string def
  { X Y WD mul add 3 mul RGBData
    dup 2 index R 255 mul cvi put
    dup 2 index 1 add G 255 mul cvi put
    exch 2 add B 255 mul cvi put
  } ImageGen

  % X BPC matrix source  multi  decode
   XI  8  IMLRTB RGBData false  [0 1 0 1 0 1]  DoImage1
  /SX SX 2 div def /SY SY 2 div def

  % ----------------------------------------------------------------------
  % 			Type 1 Stencil Mask Images

  /YY YA def
  TX YA SY add moveto (\nType 1\nStencil\nMask) blockshow

  MaskGen

  % X matrix source   decode
   XA IMLRTB MaskData  [0 1] DoImageMask
   XB IMLRTB MaskData  [1 0] DoImageMask
   XC IMLRBT MaskData  [1 0] DoImageMask
   XD IMRLTB MaskData  [1 0] DoImageMask
   XE IMRLBT MaskData  [1 0] DoImageMask
   XF IMLRTB MaskDProc [1 0] DoImageMask
   XG IMLRTB MaskDFile [1 0] DoImageMask
   MaskData (Mask) MDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 1 RGB Single Data Sources, BPC==8

  /YY YB def
  TX YY SY add moveto (\nType 1\nRGB\nBPC=8) blockshow

  /RGBData WD HD mul 3 mul string def
  { X Y WD mul add 3 mul RGBData
    dup 2 index R 255 mul cvi put
    dup 2 index 1 add G 255 mul cvi put
    exch 2 add B 255 mul cvi put
  } ImageGen

  % X BPC matrix source  multi  decode
   XA  8  IMLRTB RGBData false  [1 0 1 0 1 0]  DoImage1
   XB  8  IMLRTB RGBData false  [0 1 0 1 0 1]  DoImage1
   XC  8  IMLRBT RGBData false  [0 1 0 1 0 1]  DoImage1
   XD  8  IMRLTB RGBData false  [0 1 0 1 0 1]  DoImage1
   XE  8  IMRLBT RGBData false  [0 1 0 1 0 1]  DoImage1
   XF  8  IMLRTB RGBDProc false [0 1 0 1 0 1]  DoImage1
   XG  8  IMLRTB RGBDFile false [0 1 0 1 0 1]  DoImage1
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 1 RGB Multiple Data Sources, BPC==8

  WD HD mul /RData 1 index string def
          /GData 1 index string def
        /BData exch    string def
  { X Y WD mul add
    RData 1 index R 255 mul cvi put
    GData 1 index G 255 mul cvi put
    BData exch    B 255 mul cvi put
  } ImageGen

  % X BPC matrix source                   multi decode
   XH  8  IMLRTB [ RData GData BData ]    true  [0 1 0 1 0 1]  DoImage1
   XI  8  IMLRTB [ RDProc GDProc BDProc ] true  [0 1 0 1 0 1]  DoImage1
   XJ  8  IMLRTB [ RDFile GDFile BDFile ] true  [0 1 0 1 0 1]  DoImage1
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 4 RGB Single Data Sources, BPC==8, mask black

  /YY YE def
  TX YY SY add moveto (\nType 4\nBPC=8\nmask=black) blockshow

  % X BPC matrix source  multi  decode        MaskColor
   XA  8  IMLRTB RGBData false  [1 0 1 0 1 0] [ 000 000 000 ]  DoImage4
   XB  8  IMLRTB RGBData false  [0 1 0 1 0 1] [ 000 000 000 ]  DoImage4
   XC  8  IMLRBT RGBData false  [0 1 0 1 0 1] [ 000 000 000 ]  DoImage4
   XD  8  IMRLTB RGBData false  [0 1 0 1 0 1] [ 000 000 000 ]  DoImage4
   XE  8  IMRLBT RGBData false  [0 1 0 1 0 1] [ 000 000 000 ]  DoImage4
   XF  8  IMLRTB RGBDProc false [0 1 0 1 0 1] [ 000 000 000 ]  DoImage4
   XG  8  IMLRTB RGBDFile false [0 1 0 1 0 1] [ 000 000 000 ]  DoImage4
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 4 RGB Multiple Data Sources, BPC==8, mask black

  % X BPC matrix source                   multi decode         MaskColor
   XH  8  IMLRTB [ RData GData BData ]    true  [0 1 0 1 0 1] [ 000 000 000 ]  DoImage4
   XI  8  IMLRTB [ RDProc GDProc BDProc ] true  [0 1 0 1 0 1] [ 000 000 000 ]  DoImage4
   XJ  8  IMLRTB [ RDFile GDFile BDFile ] true  [0 1 0 1 0 1] [ 000 000 000 ]  DoImage4
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 4 RGB Single Data Sources, BPC==8, mask white

  /YY YF def
  TX YY SY add moveto (\nType 4\nBPC=8\nmask=white) blockshow

  % X BPC matrix source  multi  decode        MaskColor
   XA  8  IMLRTB RGBData false  [1 0 1 0 1 0] [ 255 255 255 ]  DoImage4
   gsave .5 .2 .2 setrgbcolor XB YY SX 13 mul SY rectfill grestore
   XB  8  IMLRTB RGBData false  [0 1 0 1 0 1] [ 255 255 255 ]  DoImage4
   XC  8  IMLRBT RGBData false  [0 1 0 1 0 1] [ 255 255 255 ]  DoImage4
   XD  8  IMRLTB RGBData false  [0 1 0 1 0 1] [ 255 255 255 ]  DoImage4
   XE  8  IMRLBT RGBData false  [0 1 0 1 0 1] [ 255 255 255 ]  DoImage4
   XF  8  IMLRTB RGBDProc false [0 1 0 1 0 1] [ 255 255 255 ]  DoImage4
   XG  8  IMLRTB RGBDFile false [0 1 0 1 0 1] [ 255 255 255 ]  DoImage4
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 4 RGB Multiple Data Sources, BPC==8, mask white

  % X BPC matrix source                   multi decode         MaskColor
   XH  8  IMLRTB [ RData GData BData ]    true  [0 1 0 1 0 1] [ 255 255 255 ]  DoImage4
   XI  8  IMLRTB [ RDProc GDProc BDProc ] true  [0 1 0 1 0 1] [ 255 255 255 ]  DoImage4
   XJ  8  IMLRTB [ RDFile GDFile BDFile ] true  [0 1 0 1 0 1] [ 255 255 255 ]  DoImage4
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 4 RGB Single Data Sources, BPC==8, mask gray

  /YY YG def
  TX YY SY add moveto (\nType 4\nBPC=8\nmask=gray) blockshow

  % X BPC matrix source  multi  decode        MaskColor
   XA  8  IMLRTB RGBData false  [1 0 1 0 1 0] [ 147 147 147 ]  DoImage4
   XB  8  IMLRTB RGBData false  [0 1 0 1 0 1] [ 147 147 147 ]  DoImage4
   XC  8  IMLRBT RGBData false  [0 1 0 1 0 1] [ 147 147 147 ]  DoImage4
   XD  8  IMRLTB RGBData false  [0 1 0 1 0 1] [ 147 147 147 ]  DoImage4
   XE  8  IMRLBT RGBData false  [0 1 0 1 0 1] [ 147 147 147 ]  DoImage4
   XF  8  IMLRTB RGBDProc false [0 1 0 1 0 1] [ 147 147 147 ]  DoImage4
   XG  8  IMLRTB RGBDFile false [0 1 0 1 0 1] [ 147 147 147 ]  DoImage4
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 4 RGB Multiple Data Sources, BPC==8, mask gray

  % X BPC matrix source                   multi decode         MaskColor
   XH  8  IMLRTB [ RData GData BData ]    true  [0 1 0 1 0 1] [ 147 147 147 ]  DoImage4
   XI  8  IMLRTB [ RDProc GDProc BDProc ] true  [0 1 0 1 0 1] [ 147 147 147 ]  DoImage4
   XJ  8  IMLRTB [ RDFile GDFile BDFile ] true  [0 1 0 1 0 1] [ 147 147 147 ]  DoImage4
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 4 RGB Single Data Sources, BPC==8, mask range

  /YY YH def
  TX YY SY add moveto (\nType 4\nBPC=8\nmask range) blockshow

  % X BPC matrix source  multi  decode        MaskColor
   XA  8  IMLRTB RGBData false  [1 0 1 0 1 0] [ 020 200 020 200 020 200 ]  DoImage4
   XB  8  IMLRTB RGBData false  [0 1 0 1 0 1] [ 020 200 020 200 020 200 ]  DoImage4
   XC  8  IMLRBT RGBData false  [0 1 0 1 0 1] [ 020 200 020 200 020 200 ]  DoImage4
   XD  8  IMRLTB RGBData false  [0 1 0 1 0 1] [ 020 200 020 200 020 200 ]  DoImage4
   XE  8  IMRLBT RGBData false  [0 1 0 1 0 1] [ 020 200 020 200 020 200 ]  DoImage4
   XF  8  IMLRTB RGBDProc false [0 1 0 1 0 1] [ 020 200 020 200 020 200 ]  DoImage4
   XG  8  IMLRTB RGBDFile false [0 1 0 1 0 1] [ 020 200 020 200 020 200 ]  DoImage4
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 4 RGB Multiple Data Sources, BPC==8, mask range

  % X  Y SX SY BPC matrix source                   multi decode         MaskColor
   XH  8  IMLRTB [ RData GData BData ]    true  [0 1 0 1 0 1] [ 020 200 020 200 020 200 ]  DoImage4
   XI  8  IMLRTB [ RDProc GDProc BDProc ] true  [0 1 0 1 0 1] [ 020 200 020 200 020 200 ]  DoImage4
   XJ  8  IMLRTB [ RDFile GDFile BDFile ] true  [0 1 0 1 0 1] [ 020 200 020 200 020 200 ]  DoImage4
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 1 RGB Single Data Sources, BPC==12

  /YY YC def
  TX YY SY add moveto (\nType 1\nRGB\nBPC=12) blockshow

  /RGBData WD 36 mul 7 add 8 div cvi HD mul string def
  {
    X 36 mul 8 div Y WD 36 mul 7 add 8 div cvi mul add
    RGBData 1 index R put12bit
    RGBData 1 index 1.5 add G put12bit
    RGBData exch 3 add B put12bit
  } ImageGen

  % X BPC matrix source  multi  decode
   XA  12 IMLRTB RGBData false  [1 0 1 0 1 0]  DoImage1
   XB  12 IMLRTB RGBData false  [0 1 0 1 0 1]  DoImage1
   XC  12 IMLRBT RGBData false  [0 1 0 1 0 1]  DoImage1
   XD  12 IMRLTB RGBData false  [0 1 0 1 0 1]  DoImage1
   XE  12 IMRLBT RGBData false  [0 1 0 1 0 1]  DoImage1
   XF  12 IMLRTB RGBDProc false [0 1 0 1 0 1]  DoImage1
   XG  12 IMLRTB RGBDFile false [0 1 0 1 0 1]  DoImage1
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 1 RGB Multiple Data Sources, BPC==12

  WD 3 mul 1 add 2 div cvi HD mul /RData 1 index string def
          /GData 1 index string def
        /BData exch    string def
  {
    X 3 mul 2 div Y WD 3 mul 1 add 2 div cvi mul add
    RData 1 index R put12bit
    GData 1 index G put12bit
    BData exch B put12bit
  } ImageGen

  % X BPC matrix source                   multi decode
   XH  12 IMLRTB [ RData GData BData ]    true  [0 1 0 1 0 1]  DoImage1
   XI  12 IMLRTB [ RDProc GDProc BDProc ] true  [0 1 0 1 0 1]  DoImage1
   XJ  12 IMLRTB [ RDFile GDFile BDFile ] true  [0 1 0 1 0 1]  DoImage1
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 4 RGB Single Data Sources, BPC==12, mask range

  /YY YI def
  TX YY SY add moveto (\nType 4\nBPC=12\nmask range) blockshow

  % X BPC matrix source  multi  decode        MaskColor
   XA 12  IMLRTB RGBData false  [1 0 1 0 1 0] [ 300 3000 300 3000 300 3000 ]  DoImage4
   XB 12  IMLRTB RGBData false  [0 1 0 1 0 1] [ 300 3000 300 3000 300 3000 ]  DoImage4
   XC 12  IMLRBT RGBData false  [0 1 0 1 0 1] [ 300 3000 300 3000 300 3000 ]  DoImage4
   XD 12  IMRLTB RGBData false  [0 1 0 1 0 1] [ 300 3000 300 3000 300 3000 ]  DoImage4
   XE 12  IMRLBT RGBData false  [0 1 0 1 0 1] [ 300 3000 300 3000 300 3000 ]  DoImage4
   XF 12  IMLRTB RGBDProc false [0 1 0 1 0 1] [ 300 3000 300 3000 300 3000 ]  DoImage4
   XG 12  IMLRTB RGBDFile false [0 1 0 1 0 1] [ 300 3000 300 3000 300 3000 ]  DoImage4
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 4 RGB Multiple Data Sources, BPC==12, mask range

  % X BPC matrix source                   multi decode         MaskColor
   XH 12  IMLRTB [ RData GData BData ]    true  [0 1 0 1 0 1] [ 300 3000 300 3000 300 3000 ]  DoImage4
   XI 12  IMLRTB [ RDProc GDProc BDProc ] true  [0 1 0 1 0 1] [ 300 3000 300 3000 300 3000 ]  DoImage4
   XJ 12  IMLRTB [ RDFile GDFile BDFile ] true  [0 1 0 1 0 1] [ 300 3000 300 3000 300 3000 ]  DoImage4
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 1 RGB Single Data Sources, BPC==4

  /YY YD def
  TX YY SY add moveto (\nType 1\nRGB\nBPC=4) blockshow

  /RGBData WD 12 mul 7 add 8 div cvi HD mul string def
  {
    X 12 mul 8 div Y WD 12 mul 7 add 8 div cvi mul add
    RGBData 1 index         R put4bit
    RGBData 1 index 0.5 add G put4bit
    RGBData exch    1.0 add B put4bit
  } ImageGen

  % X BPC matrix source  multi  decode
   XA  4  IMLRTB RGBData false  [1 0 1 0 1 0]  DoImage1
   XB  4  IMLRTB RGBData false  [0 1 0 1 0 1]  DoImage1
   XC  4  IMLRBT RGBData false  [0 1 0 1 0 1]  DoImage1
   XD  4  IMRLTB RGBData false  [0 1 0 1 0 1]  DoImage1
   XE  4  IMRLBT RGBData false  [0 1 0 1 0 1]  DoImage1
   XF  4  IMLRTB RGBDProc false [0 1 0 1 0 1]  DoImage1
   XG  4  IMLRTB RGBDFile false [0 1 0 1 0 1]  DoImage1
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 1 RGB Multiple Data Sources, BPC==4

  WD 1 add 2 div cvi HD mul /RData 1 index string def
          /GData 1 index string def
        /BData exch    string def
  {
    X 2 div Y WD 1 add 2 div cvi mul add
    RData 1 index R put4bit
    GData 1 index G put4bit
    BData exch    B put4bit
  } ImageGen

  % X BPC matrix source                   multi decode
   XH  4  IMLRTB [ RData GData BData ]    true  [0 1 0 1 0 1]  DoImage1
   XI  4  IMLRTB [ RDProc GDProc BDProc ] true  [0 1 0 1 0 1]  DoImage1
   XJ  4  IMLRTB [ RDFile GDFile BDFile ] true  [0 1 0 1 0 1]  DoImage1
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 4 RGB Single Data Sources, BPC==4, mask range

  /YY YJ def
  TX YY SY add moveto (\nType 4\nBPC=4\nmask range) blockshow

  % X BPC matrix source  multi  decode        MaskColor
   XA  4  IMLRTB RGBData false  [1 0 1 0 1 0] [ 1 10 1 10 1 10 ]  DoImage4
   XB  4  IMLRTB RGBData false  [0 1 0 1 0 1] [ 1 10 1 10 1 10 ]  DoImage4
   XC  4  IMLRBT RGBData false  [0 1 0 1 0 1] [ 1 10 1 10 1 10 ]  DoImage4
   XD  4  IMRLTB RGBData false  [0 1 0 1 0 1] [ 1 10 1 10 1 10 ]  DoImage4
   XE  4  IMRLBT RGBData false  [0 1 0 1 0 1] [ 1 10 1 10 1 10 ]  DoImage4
   XF  4  IMLRTB RGBDProc false [0 1 0 1 0 1] [ 1 10 1 10 1 10 ]  DoImage4
   XG  4  IMLRTB RGBDFile false [0 1 0 1 0 1] [ 1 10 1 10 1 10 ]  DoImage4
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

  % ----------------------------------------------------------------------
  % 			Type 4 RGB Multiple Data Sources, BPC==4, mask range

  % X BPC matrix source                   multi decode         MaskColor
   XH  4  IMLRTB [ RData GData BData ]    true  [0 1 0 1 0 1] [ 1 10 1 10 1 10 ]  DoImage4
   XI  4  IMLRTB [ RDProc GDProc BDProc ] true  [0 1 0 1 0 1] [ 1 10 1 10 1 10 ]  DoImage4
   XJ  4  IMLRTB [ RDFile GDFile BDFile ] true  [0 1 0 1 0 1] [ 1 10 1 10 1 10 ]  DoImage4
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

  showpage

} bind def 	% T1T4Tests

% -----------------------------------------------------------------------
%
% Type 3 Tests

/T3Tests {
  % Use an unusual (unpleasant?) underlying color
  .6 .95 .4 setrgbcolor clippath fill

  0 0 0 setrgbcolor
  TitleFont setfont
  200 760 moveto (Image Type 3 Tests) show
  200 740 moveto (Rotation Angle = ) show IR 3 string cvs show
  170 720 moveto (Colorspace = ) show CSpaceName show
  LegendFont setfont

  .4 .1 .7 setrgbcolor	% contrasting color for stencil masking

  /WM WD def
  /HM HD def
  /SX SX 2 mul def /SY SY 2 mul def
  /YY 780 SY sub def
  MaskGen
  XA IMLRTB MaskData  [1 0] DoImageMask

  /RGBData WD HD mul 3 mul string def
  { X Y WD mul add 3 mul RGBData
    dup 2 index R 255 mul cvi put
    dup 2 index 1 add G 255 mul cvi put
    exch 2 add B 255 mul cvi put
  } ImageGen

  % X BPC matrix source  multi  decode
   XH  8  IMLRTB RGBData false  [0 1 0 1 0 1]  DoImage1
  /SX SX 2 div def /SY SY 2 div def

% ----------------------------------------------------------------------
% 		InterleaveType 1, BPC==8, WM=WD, HM=HD
%		IT 1 is what GS calls "chunky pixel"
  /YY YA def
  TX YY SY add moveto (\nIntType 1\nBPC=8) blockshow

  % Generate the MaskData first
  8 MaskGenBPC

  % Generate the Data Image (uses the MaskData)
  /RGBData WD HD mul 4 mul string def
  { X Y WD mul add 4 mul		% 4 bytes Mask,Red,Green,Blue
    RGBData
    dup 2 index       MaskData X Y WB mul add get put
    dup 2 index 1 add R 255 mul cvi put
    dup 2 index 2 add G 255 mul cvi put
    exch        3 add B 255 mul cvi put
  }
  ImageGen

  % X BPC matrix source  multi MaskDecode DataDecode   IT DoImage3 -
   XA  8  IMLRTB RGBData false  [0 1]    [1 0 1 0 1 0]  1 DoImage3
   XB  8  IMLRTB RGBData false  [1 0]    [1 0 1 0 1 0]  1 DoImage3
   XC  8  IMLRTB RGBData false  [0 1]    [0 1 0 1 0 1]  1 DoImage3
   XD  8  IMLRTB RGBData false  [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XE  8  IMLRBT RGBData false  [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XF  8  IMRLTB RGBData false  [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XG  8  IMRLBT RGBData false  [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XH  8  IMLRTB RGBDProc false [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XI  8  IMLRTB RGBDFile false [1 0]    [0 1 0 1 0 1]  1 DoImage3
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 1, BPC==12, WM=WD, HM=HD
%		IT 1 is what GS calls "chunky pixel"
  /YY YB def
  TX YY SY add moveto (\nIntType 1\nBPC=12) blockshow

  % Generate the MaskData first
  12 MaskGenBPC

  % Generate the Data Image (uses the MaskData)
  /RGBData WD HD mul 6 mul string def
  { X Y WD mul add 6 mul		% 6 bytes Mask,Red,Green,Blue
    RGBData
    dup 2 index
                      MaskData X 1.5 mul .5 add cvi
                      Y WB mul add get	% get the aligned mask byte (hi or lo)
                      0 eq { 0 } { 1 } ifelse
                      put12bit
    dup 2 index 1.5 add R put12bit
    dup 2 index 3.0 add G put12bit
    exch        4.5 add B put12bit
  }
  ImageGen

  % X BPC matrix source  multi MaskDecode DataDecode   IT DoImage3 -
   XA 12  IMLRTB RGBData false  [0 1]    [1 0 1 0 1 0]  1 DoImage3
   XB 12  IMLRTB RGBData false  [1 0]    [1 0 1 0 1 0]  1 DoImage3
   XC 12  IMLRTB RGBData false  [0 1]    [0 1 0 1 0 1]  1 DoImage3
   XD 12  IMLRTB RGBData false  [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XE 12  IMLRBT RGBData false  [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XF 12  IMRLTB RGBData false  [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XG 12  IMRLBT RGBData false  [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XH 12  IMLRTB RGBDProc false [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XI 12  IMLRTB RGBDFile false [1 0]    [0 1 0 1 0 1]  1 DoImage3
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 1, BPC==4, WM=WD, HM=HD
%		IT 1 is what GS calls "chunky pixel"
  /YY YC def
  TX YY SY add moveto (\nIntType 1\nBPC=4) blockshow

  % Generate the MaskData first
  4 MaskGenBPC

  % Generate the Data Image (uses the MaskData)
  /RGBData WD HD mul 2 mul string def
  { X Y WD mul add 2 mul		% 2 bytes Mask,Red,Green,Blue
    RGBData
    dup 2 index       MaskData X 2 div cvi Y WB mul add get
                      X 1 and 0 eq { 128 div cvi } { 1 and } ifelse
                      put4bit
    dup 2 index 0.5 add R put4bit
    dup 2 index 1.0 add G put4bit
    exch        1.5 add B put4bit
  }
  ImageGen

  % X BPC matrix source  multi MaskDecode DataDecode   IT DoImage3 -
   XA  4  IMLRTB RGBData false  [0 1]    [1 0 1 0 1 0]  1 DoImage3
   XB  4  IMLRTB RGBData false  [1 0]    [1 0 1 0 1 0]  1 DoImage3
   XC  4  IMLRTB RGBData false  [0 1]    [0 1 0 1 0 1]  1 DoImage3
   XD  4  IMLRTB RGBData false  [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XE  4  IMLRBT RGBData false  [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XF  4  IMRLTB RGBData false  [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XG  4  IMRLBT RGBData false  [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XH  4  IMLRTB RGBDProc false [1 0]    [0 1 0 1 0 1]  1 DoImage3
   XI  4  IMLRTB RGBDFile false [1 0]    [0 1 0 1 0 1]  1 DoImage3
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 2, BPC==8, WM=WD, HM=HD
%		IT 2 is line interleave -- Mask line follwoed by Data line
%		RGB Image Data must be chunky (MultipleDatasources==false).
  /YY YD def
  TX YY SY add moveto (\nIntType 2\nBPC=8) blockshow

  % Generate the MaskData first
  MaskGen

  % Generate the Data Image (uses the MaskData)
  /BPL WD 3 mul WB add cvi def		% BytesPerLine
  /RGBData BPL HD mul string def
  { X 3 mul Y BPL mul add WB add  		% 3 bytes Red,Green,Blue + Mask Bytes
    X 0 eq {
      RGBData 1 index WB sub
      MaskData Y WB mul WB getinterval
      putinterval
    } if
    RGBData
    dup 2 index        R 255 mul cvi put
    dup 2 index 1 add G 255 mul cvi put
    exch        2 add B 255 mul cvi put
  }
  ImageGen

  % X BPC matrix source  multi MaskDecode DataDecode   IT DoImage3 -
   XA  8  IMLRTB RGBData false  [0 1]    [1 0 1 0 1 0]  2 DoImage3
   XB  8  IMLRTB RGBData false  [1 0]    [1 0 1 0 1 0]  2 DoImage3
   XC  8  IMLRTB RGBData false  [0 1]    [0 1 0 1 0 1]  2 DoImage3
   XD  8  IMLRTB RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XE  8  IMLRBT RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XF  8  IMRLTB RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XG  8  IMRLBT RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XH  8  IMLRTB RGBDProc false [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XI  8  IMLRTB RGBDFile false [1 0]    [0 1 0 1 0 1]  2 DoImage3
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 2, BPC==12, WM=WD, HM=HD
  /YY YE def
  TX YY SY add moveto (\nIntType 2\nBPC=12) blockshow

  % Generate the Data Image (uses the MaskData)
  /BPL WD 36 mul 7 add 8 div cvi WB add def		% BytesPerLine
  /RGBData BPL HD mul string def
  { X 36 mul 8 div Y BPL mul add WB add
    X 0 eq {
      RGBData 1 index WB sub cvi
      MaskData Y WB mul WB getinterval
      putinterval
    } if
    RGBData
    dup 2 index         R put12bit
    dup 2 index 1.5 add G put12bit
    exch        3.0 add B put12bit
  }
  ImageGen

  % X BPC matrix source  multi MaskDecode DataDecode   IT DoImage3 -
   XA 12  IMLRTB RGBData false  [0 1]    [1 0 1 0 1 0]  2 DoImage3
   XB 12  IMLRTB RGBData false  [1 0]    [1 0 1 0 1 0]  2 DoImage3
   XC 12  IMLRTB RGBData false  [0 1]    [0 1 0 1 0 1]  2 DoImage3
   XD 12  IMLRTB RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XE 12  IMLRBT RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XF 12  IMRLTB RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XG 12  IMRLBT RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XH 12  IMLRTB RGBDProc false [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XI 12  IMLRTB RGBDFile false [1 0]    [0 1 0 1 0 1]  2 DoImage3
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 2, BPC==4, WM=WD, HM=HD
  /YY YF def
  TX YY SY add moveto (\nIntType 2\nBPC=4) blockshow

  % Generate the Data Image (uses the MaskData)
  /BPL WD 12 mul 7 add 8 div cvi WB add def		% BytesPerLine
  /RGBData BPL HD mul string def
  { X 12 mul 8 div Y BPL mul add WB add
    X 0 eq {
      RGBData 1 index WB sub cvi
      MaskData Y WB mul WB getinterval
      putinterval
    } if
    RGBData
    dup 2 index         R put4bit
    dup 2 index 0.5 add G put4bit
    exch        1.0 add B put4bit
  }
  ImageGen

  % X BPC matrix source  multi MaskDecode DataDecode   IT DoImage3 -
   XA  4  IMLRTB RGBData false  [0 1]    [1 0 1 0 1 0]  2 DoImage3
   XB  4  IMLRTB RGBData false  [1 0]    [1 0 1 0 1 0]  2 DoImage3
   XC  4  IMLRTB RGBData false  [0 1]    [0 1 0 1 0 1]  2 DoImage3
   XD  4  IMLRTB RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XE  4  IMLRBT RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XF  4  IMRLTB RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XG  4  IMRLBT RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XH  4  IMLRTB RGBDProc false [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XI  4  IMLRTB RGBDFile false [1 0]    [0 1 0 1 0 1]  2 DoImage3
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 2, BPC==8, WM=.6*WD, HM=HD/2
%		IT 2 is line interleave -- Mask line follwoed by Data line
%		RGB Image Data must be chunky (MultipleDatasources==false).
  /YY YG def
  TX YY SY add moveto (\nIntType 2\nBPC=8\nWM=.6*WD\nHM=HD/2) blockshow

  % Generate the MaskData first
  /WM WD .6 mul cvi def
  /HM HD 2 div cvi def
  /saveHD HD def
  /HD HM 2 mul def		% make HD even for this exercise
  MaskGen

  % Generate the Data Image (uses the MaskData)
  /BPL WD 3 mul def		% BytesPerLine RGB Data
  /RGBData BPL HD mul WB HM mul add string def
  { X 3 mul Y BPL mul add Y 2 div cvi 1 add WB mul add	% 3 bytes Red,Green,Blue + Mask
    X 0 eq Y 1 and 0 eq and {			% Do one row of Mask every other image row
      RGBData 1 index WB sub
      MaskData Y 2 div cvi WB mul WB getinterval
      putinterval
    } if
    RGBData
    dup 2 index        R 255 mul cvi put
    dup 2 index 1 add G 255 mul cvi put
    exch        2 add B 255 mul cvi put
  }
  ImageGen

%DEBUG	/xx (xx) (w) file def
%DEBUG	0 1 HM 1 sub { MaskData exch WB mul WB getinterval xx exch writehexstring xx (\n) writestring } for
%DEBUG	xx (----------------------------------------------------------------\n) writestring
%DEBUG	0 2 HD 1 sub {
%DEBUG	  RGBData 1 index BPL mul 2 index 2 div cvi WB mul add
%DEBUG	  WB getinterval xx exch writehexstring xx (\n) writestring
%DEBUG	  RGBData 1 index BPL mul 2 index 2 div cvi 1 add WB mul add
%DEBUG	  BPL getinterval xx exch writehexstring xx (\n) writestring
%DEBUG	  RGBData 1 index 1 add BPL mul 2 index 2 div cvi 1 add WB mul add
%DEBUG	  BPL getinterval xx exch writehexstring xx (\n) writestring
%DEBUG	  pop
%DEBUG	} for
%DEBUG	xx closefile

  % X BPC matrix source  multi MaskDecode DataDecode   IT DoImage3 -
   XA  8  IMLRTB RGBData false  [0 1]    [1 0 1 0 1 0]  2 DoImage3
   XB  8  IMLRTB RGBData false  [1 0]    [1 0 1 0 1 0]  2 DoImage3
   XC  8  IMLRTB RGBData false  [0 1]    [0 1 0 1 0 1]  2 DoImage3
   XD  8  IMLRTB RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XE  8  IMLRBT RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XF  8  IMRLTB RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XG  8  IMRLBT RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XH  8  IMLRTB RGBDProc false [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XI  8  IMLRTB RGBDFile false [1 0]    [0 1 0 1 0 1]  2 DoImage3
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

   /HD saveHD def		% put odd HD back

% ----------------------------------------------------------------------
% 		InterleaveType 2, BPC==8, WM=1.3*WD, HM=2*HD
%		IT 2 is line interleave -- Mask line follwoed by Data line
%		RGB Image Data must be chunky (MultipleDatasources==false).
  /YY YH def
  TX YY SY add moveto (\nIntType 2\nBPC=8\nWM=1.3*WD\nHM=2*HD) blockshow

  % Generate the MaskData first
  /WM WD 1.3 mul cvi def
  /HM HD 2 mul def
  MaskGen

  % Generate the Data Image (uses the MaskData)
  /HR HM HD div cvi def
  /BPL WD 3 mul WB HR mul add cvi def		% BytesPerLine
  /RGBData BPL HD mul string def
  { X 3 mul Y BPL mul add WB HR mul add 	% 3 bytes Red,Green,Blue + Mask Bytes
    X 0 eq {				% Do HM/HD rows of Mask
      RGBData 1 index WB HR mul sub
      MaskData Y WB HR mul mul WB HR mul getinterval
      putinterval
    } if
    RGBData
    dup 2 index        R 255 mul cvi put
    dup 2 index 1 add G 255 mul cvi put
    exch        2 add B 255 mul cvi put
  }
  ImageGen

  % X BPC matrix source  multi MaskDecode DataDecode   IT DoImage3 -
   XA  8  IMLRTB RGBData false  [0 1]    [1 0 1 0 1 0]  2 DoImage3
   XB  8  IMLRTB RGBData false  [1 0]    [1 0 1 0 1 0]  2 DoImage3
   XC  8  IMLRTB RGBData false  [0 1]    [0 1 0 1 0 1]  2 DoImage3
   XD  8  IMLRTB RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XE  8  IMLRBT RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XF  8  IMRLTB RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XG  8  IMRLBT RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XH  8  IMLRTB RGBDProc false [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XI  8  IMLRTB RGBDFile false [1 0]    [0 1 0 1 0 1]  2 DoImage3
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed
% ----------------------------------------------------------------------
% 		InterleaveType 2, BPC==12, WM=1.3*WD, HM=2*HD
  /YY YI def
  TX YY SY add moveto (\nIntType 2\nBPC=12\nWM=1.3*WD\nHM=2*HD) blockshow

  % Generate the Data Image (uses the MaskData)
  /HR HM HD div cvi def
  /BPL WD 36 mul 7 add 8 div cvi WB HR mul add def		% BytesPerLine
  /RGBData BPL HD mul string def
  { X 36 mul 8 div Y BPL mul add WB HR mul add
    X 0 eq {
      RGBData 1 index WB HR mul sub cvi
      MaskData Y WB HR mul mul WB HR mul getinterval
      putinterval
    } if
    RGBData
    dup 2 index         R put12bit
    dup 2 index 1.5 add G put12bit
    exch        3.0 add B put12bit
  }
  ImageGen

  % X BPC matrix source  multi MaskDecode DataDecode   IT DoImage3 -
   XA 12  IMLRTB RGBData false  [0 1]    [1 0 1 0 1 0]  2 DoImage3
   XB 12  IMLRTB RGBData false  [1 0]    [1 0 1 0 1 0]  2 DoImage3
   XC 12  IMLRTB RGBData false  [0 1]    [0 1 0 1 0 1]  2 DoImage3
   XD 12  IMLRTB RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XE 12  IMLRBT RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XF 12  IMRLTB RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XG 12  IMRLBT RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XH 12  IMLRTB RGBDProc false [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XI 12  IMLRTB RGBDFile false [1 0]    [0 1 0 1 0 1]  2 DoImage3
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 2, BPC==4, WM=1.3*WD, HM=2*HD
  /YY YJ def
  TX YY SY add moveto (\nIntType 2\nBPC=4\nWM=1.3*WD\nHM=2*HD) blockshow

  % Generate the Data Image (uses the MaskData)
  /HR HM HD div cvi def
  /BPL WD 12 mul 7 add 8 div cvi WB HR mul add def		% BytesPerLine
  /RGBData BPL HD mul string def
  { X 12 mul 8 div Y BPL mul add WB HR mul add
    X 0 eq {
      RGBData 1 index WB HR mul sub cvi
      MaskData Y WB HR mul mul WB HR mul getinterval
      putinterval
    } if
    RGBData
    dup 2 index         R put4bit
    dup 2 index 0.5 add G put4bit
    exch        1.0 add B put4bit
  }
  ImageGen

  % X BPC matrix source  multi MaskDecode DataDecode   IT DoImage3 -
   XA  4  IMLRTB RGBData false  [0 1]    [1 0 1 0 1 0]  2 DoImage3
   XB  4  IMLRTB RGBData false  [1 0]    [1 0 1 0 1 0]  2 DoImage3
   XC  4  IMLRTB RGBData false  [0 1]    [0 1 0 1 0 1]  2 DoImage3
   XD  4  IMLRTB RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XE  4  IMLRBT RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XF  4  IMRLTB RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XG  4  IMRLBT RGBData false  [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XH  4  IMLRTB RGBDProc false [1 0]    [0 1 0 1 0 1]  2 DoImage3
   XI  4  IMLRTB RGBDFile false [1 0]    [0 1 0 1 0 1]  2 DoImage3
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

  showpage
% ----------------------------------------------------------------------

  % Use an unusual (unpleasant?) underlying color
  .6 .95 .4 setrgbcolor clippath fill

  0 0 0 setrgbcolor
  TitleFont setfont
  200 760 moveto (Image Type 3 Tests) show
  200 740 moveto (Rotation Angle = ) show IR 3 string cvs show
  200 720 moveto (InterleaveType 3) show
  170 700 moveto (Colorspace = ) show CSpaceName show
  LegendFont setfont

  .4 .1 .7 setrgbcolor	% contrasting color for stencil masking

% ----------------------------------------------------------------------
% 		InterleaveType 3, BPC==8, WM=WD, HM=HD
%		IT 3 is line interleave -- Mask and Data in separate sources
%		RGB Image Data chunky (MultipleDatasources==false).
  /YY YA def
  TX YY SY add moveto (BPC=8\nMulti\nfalse) blockshow

  % Generate the MaskData first
  /WM WD def
  /HM HD def
  MaskGen

  % Generate the Data Image
  /RGBData WD HD mul 3 mul string def
  { X Y WD mul add 3 mul RGBData
    dup 2 index R 255 mul cvi put
    dup 2 index 1 add G 255 mul cvi put
    exch 2 add B 255 mul cvi put
  } ImageGen

  % X BPC matrix source                 multi MaskDecode DataDecode   IT DoImage3 -
   XA  8  IMLRTB [ MaskData  RGBData  ] false  [0 1]    [1 0 1 0 1 0]  3 DoImage3
   XB  8  IMLRTB [ MaskData  RGBData  ] false  [1 0]    [1 0 1 0 1 0]  3 DoImage3
   XC  8  IMLRTB [ MaskData  RGBData  ] false  [0 1]    [0 1 0 1 0 1]  3 DoImage3
   XD  8  IMLRTB [ MaskData  RGBData  ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XE  8  IMLRBT [ MaskData  RGBData  ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XF  8  IMRLTB [ MaskData  RGBData  ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XG  8  IMRLBT [ MaskData  RGBData  ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XH  8  IMLRTB [ MaskDProc RGBDProc ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XI  8  IMLRTB [ MaskDFile RGBDFile ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   MaskData (Mask) MDF CheckFileTail % Check that the correct amount of data was consumed
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 3, BPC==12, WM=WD, HM=HD
  /YY YB def
  TX YY SY add moveto (BPC=12\nMulti\nfalse) blockshow

  /RGBData WD 36 mul 7 add 8 div cvi HD mul string def
  {
    X 36 mul 8 div Y WD 36 mul 7 add 8 div cvi mul add
    RGBData 1 index R put12bit
    RGBData 1 index 1.5 add G put12bit
    RGBData exch 3 add B put12bit
  } ImageGen

  % X BPC matrix source                 multi MaskDecode DataDecode   IT DoImage3 -
   XA 12  IMLRTB [ MaskData  RGBData  ] false  [0 1]    [1 0 1 0 1 0]  3 DoImage3
   XB 12  IMLRTB [ MaskData  RGBData  ] false  [1 0]    [1 0 1 0 1 0]  3 DoImage3
   XC 12  IMLRTB [ MaskData  RGBData  ] false  [0 1]    [0 1 0 1 0 1]  3 DoImage3
   XD 12  IMLRTB [ MaskData  RGBData  ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XE 12  IMLRBT [ MaskData  RGBData  ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XF 12  IMRLTB [ MaskData  RGBData  ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XG 12  IMRLBT [ MaskData  RGBData  ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XH 12  IMLRTB [ MaskDProc RGBDProc ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XI 12  IMLRTB [ MaskDFile RGBDFile ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   MaskData (Mask) MDF CheckFileTail % Check that the correct amount of data was consumed
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 3, BPC==4, WM=WD, HM=HD
  /YY YC def
  TX YY SY add moveto (BPC=4\nMulti\nfalse) blockshow

  /RGBData WD 12 mul 7 add 8 div cvi HD mul string def
  {
    X 12 mul 8 div Y WD 12 mul 7 add 8 div cvi mul add
    RGBData 1 index         R put4bit
    RGBData 1 index 0.5 add G put4bit
    RGBData exch    1.0 add B put4bit
  } ImageGen

  % X BPC matrix source                 multi MaskDecode DataDecode   IT DoImage3 -
   XA  4  IMLRTB [ MaskData  RGBData  ] false  [0 1]    [1 0 1 0 1 0]  3 DoImage3
   XB  4  IMLRTB [ MaskData  RGBData  ] false  [1 0]    [1 0 1 0 1 0]  3 DoImage3
   XC  4  IMLRTB [ MaskData  RGBData  ] false  [0 1]    [0 1 0 1 0 1]  3 DoImage3
   XD  4  IMLRTB [ MaskData  RGBData  ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XE  4  IMLRBT [ MaskData  RGBData  ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XF  4  IMRLTB [ MaskData  RGBData  ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XG  4  IMRLBT [ MaskData  RGBData  ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XH  4  IMLRTB [ MaskDProc RGBDProc ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XI  4  IMLRTB [ MaskDFile RGBDFile ] false  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   MaskData (Mask) MDF CheckFileTail % Check that the correct amount of data was consumed
   RGBData (RGB) RGBDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 3, BPC==8, WM=WD, HM=HD
%		IT 3 is line interleave -- Mask and Data in separate sources
%		RGB Image Data seprate (MultipleDatasources==true).
  /YY YA def
  TX YY SY add moveto (BPC=8\nMulti\ntrue) blockshow

  % Generate the MaskData first
  MaskGen

  % Generate the Data Image
  WD HD mul /RData 1 index string def
          /GData 1 index string def
        /BData exch    string def
  { X Y WD mul add
    RData 1 index R 255 mul cvi put
    GData 1 index G 255 mul cvi put
    BData exch    B 255 mul cvi put
  } ImageGen

  % X BPC matrix source                              multi MaskDecode DataDecode   IT DoImage3 -
   XA  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [1 0 1 0 1 0]  3 DoImage3
   XB  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [1 0 1 0 1 0]  3 DoImage3
   XC  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [0 1 0 1 0 1]  3 DoImage3
   XD  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XE  8  IMLRBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XF  8  IMRLTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XG  8  IMRLBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XH  8  IMLRTB [ MaskDProc [RDProc GDProc BDProc]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XI  8  IMLRTB [ MaskDFile [RDFile GDFile BDFile]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   MaskData (Mask) MDF CheckFileTail % Check that the correct amount of data was consumed
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 3, BPC==8, WM=WD, HM=HD
%		IT 3 is line interleave -- Mask and Data in separate sources
%		RGB Image Data seprate (MultipleDatasources==true).
  /YY YD def
  TX YY SY add moveto (BPC=8\nMulti\ntrue) blockshow

  % Generate the MaskData first
  MaskGen

  % Generate the Data Image
  WD HD mul /RData 1 index string def
          /GData 1 index string def
        /BData exch    string def
  { X Y WD mul add
    RData 1 index R 255 mul cvi put
    GData 1 index G 255 mul cvi put
    BData exch    B 255 mul cvi put
  } ImageGen

  % X BPC matrix source                              multi MaskDecode DataDecode   IT DoImage3 -
   XA  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [1 0 1 0 1 0]  3 DoImage3
   XB  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [1 0 1 0 1 0]  3 DoImage3
   XC  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [0 1 0 1 0 1]  3 DoImage3
   XD  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XE  8  IMLRBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XF  8  IMRLTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XG  8  IMRLBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XH  8  IMLRTB [ MaskDProc [RDProc GDProc BDProc]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XI  8  IMLRTB [ MaskDFile [RDFile GDFile BDFile]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   MaskData (Mask) MDF CheckFileTail % Check that the correct amount of data was consumed
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 3, BPC==12, WM=WD, HM=HD
  /YY YE def
  TX YY SY add moveto (BPC=12\nMulti\ntrue) blockshow

  WD 3 mul 1 add 2 div cvi HD mul /RData 1 index string def
          /GData 1 index string def
        /BData exch    string def
  {
    X 3 mul 2 div Y WD 3 mul 1 add 2 div cvi mul add
    RData 1 index R put12bit
    GData 1 index G put12bit
    BData exch B put12bit
  } ImageGen

  % X BPC matrix source                              multi MaskDecode DataDecode   IT DoImage3 -
   XA 12  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [1 0 1 0 1 0]  3 DoImage3
   XB 12  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [1 0 1 0 1 0]  3 DoImage3
   XC 12  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [0 1 0 1 0 1]  3 DoImage3
   XD 12  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XE 12  IMLRBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XF 12  IMRLTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XG 12  IMRLBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XH 12  IMLRTB [ MaskDProc [RDProc GDProc BDProc]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XI 12  IMLRTB [ MaskDFile [RDFile GDFile BDFile]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   MaskData (Mask) MDF CheckFileTail % Check that the correct amount of data was consumed
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 3, BPC==4, WM=WD, HM=HD
  /YY YF def
  TX YY SY add moveto (BPC=4\nMulti\ntrue) blockshow

  WD 1 add 2 div cvi HD mul /RData 1 index string def
          /GData 1 index string def
        /BData exch    string def
  {
    X 2 div Y WD 1 add 2 div cvi mul add
    RData 1 index R put4bit
    GData 1 index G put4bit
    BData exch    B put4bit
  } ImageGen

  % X BPC matrix source                              multi MaskDecode DataDecode   IT DoImage3 -
   XA  4  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [1 0 1 0 1 0]  3 DoImage3
   XB  4  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [1 0 1 0 1 0]  3 DoImage3
   XC  4  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [0 1 0 1 0 1]  3 DoImage3
   XD  4  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XE  4  IMLRBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XF  4  IMRLTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XG  4  IMRLBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XH  4  IMLRTB [ MaskDProc [RDProc GDProc BDProc]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XI  4  IMLRTB [ MaskDFile [RDFile GDFile BDFile]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   MaskData (Mask) MDF CheckFileTail % Check that the correct amount of data was consumed
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 3, BPC==8, WM=.9*WD, HM=1.1*HD
%		IT 3 is line interleave -- Mask and Data in separate sources
%		RGB Image Data seprate (MultipleDatasources==true).
  /YY YG def
  TX YY SY add moveto (BPC=8\nMulti\ntrue\nWM=.9*WD\nHM=1.1*HD) blockshow

  /WM 0.9 WD mul cvi def
  /HM 1.1 HD mul cvi def
  % Generate the MaskData first
  MaskGen

  % Generate the Data Image
  WD HD mul /RData 1 index string def
          /GData 1 index string def
        /BData exch    string def
  { X Y WD mul add
    RData 1 index R 255 mul cvi put
    GData 1 index G 255 mul cvi put
    BData exch    B 255 mul cvi put
  } ImageGen

  % X BPC matrix source                              multi MaskDecode DataDecode   IT DoImage3 -
   XA  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [1 0 1 0 1 0]  3 DoImage3
   XB  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [1 0 1 0 1 0]  3 DoImage3
   XC  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [0 1 0 1 0 1]  3 DoImage3
   XD  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XE  8  IMLRBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XF  8  IMRLTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XG  8  IMRLBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XH  8  IMLRTB [ MaskDProc [RDProc GDProc BDProc]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XI  8  IMLRTB [ MaskDFile [RDFile GDFile BDFile]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   MaskData (Mask) MDF CheckFileTail % Check that the correct amount of data was consumed
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 3, BPC==12, WM=WD, HM=HD
  /YY YI def
  TX YY SY add moveto (BPC=12\nMulti\ntrue\nWM=.9*WD\nHM=1.1*HD) blockshow

  WD 3 mul 1 add 2 div cvi HD mul /RData 1 index string def
          /GData 1 index string def
        /BData exch    string def
  {
    X 3 mul 2 div Y WD 3 mul 1 add 2 div cvi mul add
    RData 1 index R put12bit
    GData 1 index G put12bit
    BData exch B put12bit
  } ImageGen

  % X BPC matrix source                              multi MaskDecode DataDecode   IT DoImage3 -
   XA 12  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [1 0 1 0 1 0]  3 DoImage3
   XB 12  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [1 0 1 0 1 0]  3 DoImage3
   XC 12  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [0 1 0 1 0 1]  3 DoImage3
   XD 12  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XE 12  IMLRBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XF 12  IMRLTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XG 12  IMRLBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XH 12  IMLRTB [ MaskDProc [RDProc GDProc BDProc]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XI 12  IMLRTB [ MaskDFile [RDFile GDFile BDFile]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   MaskData (Mask) MDF CheckFileTail % Check that the correct amount of data was consumed
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 3, BPC==4, WM=WD, HM=HD
  /YY YJ def
  TX YY SY add moveto (BPC=4\nMulti\ntrue\nWM=.9*WD\nHM=1.1*HD) blockshow

  WD 1 add 2 div cvi HD mul /RData 1 index string def
          /GData 1 index string def
        /BData exch    string def
  {
    X 2 div Y WD 1 add 2 div cvi mul add
    RData 1 index R put4bit
    GData 1 index G put4bit
    BData exch    B put4bit
  } ImageGen

  % X BPC matrix source                              multi MaskDecode DataDecode   IT DoImage3 -
   XA  4  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [1 0 1 0 1 0]  3 DoImage3
   XB  4  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [1 0 1 0 1 0]  3 DoImage3
   XC  4  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [0 1 0 1 0 1]  3 DoImage3
   XD  4  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XE  4  IMLRBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XF  4  IMRLTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XG  4  IMRLBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XH  4  IMLRTB [ MaskDProc [RDProc GDProc BDProc]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XI  4  IMLRTB [ MaskDFile [RDFile GDFile BDFile]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   MaskData (Mask) MDF CheckFileTail % Check that the correct amount of data was consumed
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

% ----------------------------------------------------------------------
% 		InterleaveType 3, BPC==8, WM=1.1*WD, HM=.9*HD
%		IT 3 is line interleave -- Mask and Data in separate sources
%		RGB Image Data seprate (MultipleDatasources==true).
  /YY YH def
  TX YY SY add moveto (BPC=8\nMulti\ntrue\nWM=1.1*WD\nHM=.9*HD) blockshow

  /WM 1.1 WD mul cvi def
  /HM 0.9 HD mul cvi def
  % Generate the MaskData first
  MaskGen

  % Generate the Data Image
  WD HD mul /RData 1 index string def
          /GData 1 index string def
        /BData exch    string def
  { X Y WD mul add
    RData 1 index R 255 mul cvi put
    GData 1 index G 255 mul cvi put
    BData exch    B 255 mul cvi put
  } ImageGen

  % X BPC matrix source                              multi MaskDecode DataDecode   IT DoImage3 -
   XA  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [1 0 1 0 1 0]  3 DoImage3
   XB  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [1 0 1 0 1 0]  3 DoImage3
   XC  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [0 1]    [0 1 0 1 0 1]  3 DoImage3
   XD  8  IMLRTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XE  8  IMLRBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XF  8  IMRLTB [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XG  8  IMRLBT [ MaskData  [RData  GData  BData] ] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XH  8  IMLRTB [ MaskDProc [RDProc GDProc BDProc]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   XI  8  IMLRTB [ MaskDFile [RDFile GDFile BDFile]] true  [1 0]    [0 1 0 1 0 1]  3 DoImage3
   MaskData (Mask) MDF CheckFileTail % Check that the correct amount of data was consumed
   RData (Red) RDF CheckFileTail % Check that the correct amount of data was consumed
   GData (Grn) GDF CheckFileTail % Check that the correct amount of data was consumed
   BData (Blu) BDF CheckFileTail % Check that the correct amount of data was consumed

  showpage
} bind def 	% T3Tests

% ----------------------------------------------------------------------
% 	Do the various rotations
%
/CSpace /DeviceRGB def

[ 0 10 -10 45 90 180 270 ]
pop [ 0 ]					% delete this line to enable tests
{ /IR exch def T1T4Tests } forall

[ 0 10 -10 45 90 180 270 ]
pop [ 0 ]					% delete this line to enable tests
{ /IR exch def T3Tests } forall

/CSpace [ /DeviceN [/Blue /Red /Green] /DeviceRGB { } ] def

[ 0 10 -10 45 90 180 270 ]
pop [ 0 ]					% delete this line to enable tests
{ /IR exch def T1T4Tests } forall

[ 0 10 -10 45 90 180 270 ]
pop [ 0 ]					% delete this line to enable tests
{ /IR exch def T3Tests } forall
