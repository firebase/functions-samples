%!
% Copyright (C) 2001-2012 Artifex Software, Inc.
% All Rights Reserved.
%
% This software is provided AS-IS with no warranty, either express or
% implied.
%
% This software is distributed under license and may not be copied,
% modified or distributed except as expressly authorized under the terms
% of the license contained in the file LICENSE in this distribution.
%
% Refer to licensing information at http://www.artifex.com or contact
% Artifex Software, Inc.,  7 Mt. Lassen Drive - Suite A-134, San Rafael,
% CA  94903, U.S.A., +1(415)492-9861, for further information.
%

%xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
%
%   ps2ai.ps - a postscript to editable adobe illustrator file filter
%
/vers {2.14} def                  %                    January 31, 1999

% conditional def ( if the key is already defined before, don't
% redefine it. This can be used by other programs to overwrite
% some settings from externally
%
/cdef { 1 index where { pop pop pop } { def } ifelse } bind def
%
%xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
%
% needs a postscript level 2 interpreter, like gnu ghostscript, to work
%
%      Usage:   gs -q -dNODISPLAY ps2ai.ps file.ps > file.aips
%                              or (see below)
%               gs -q -dNODISPLAY ps2ai.ps file.ps
%                              or
%               cat ps2ai.ps file.ps | lpr  (then look in log file)
%
% or from within gsview via:
% 	Edit->Convert to vector format
%xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
%                            Options
%xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
%   Output Options: directly to a file or standard out
%
/jout false cdef            % true=file  false=stdout (default=false)
/joutput (ps2ai.out.aips) cdef      % Name of Output file
%
%xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
%
%              Other Options
%
/jtxt3 true cdef           % output text in AI3 form (false=ai88)
                          % for coreldraw/photoshop readable output
/joutln false cdef         % use font outline  instead of font
/jerr false def            % use error handling (ie die gracefully)
/jbiterr false def         % attempt to handle bitmap fonts (kludge)
/jMacGS false def         % true if using MacGS (not fully implemented yet)
/jMacfix true def         % convert filled boxes to lines (only usefull with
                          % laserwriter 8 postscript input)

%
%xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
%                    No options below here
%xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
%
%         - Notes -
%  ai uses cmykcolor, so level 1 interpreters don't work
%  ai doesn't use image/imagemask - so bitmaps don't work correctly
%  the output file has a header so it is viewable/printable/reconvertable
%
% Comments, suggestions, bug-fixes, etc send to:
%
%        Jason Olszewski (olszewsk@splash.princeton.edu)
%
% anonymous ftp: toby.princeton.edu /pub/olszewsk/ps2ai.ps
%       URL ftp://toby.princeton.edu/pub/olszewsk
%
%         - Fix History -
%  2.14 added cdef to allow overwriting of certain values from externally
%  2.13 check for bitmap fonts, work better with TeX,WinPS,etc
%  2.12 fixed initclip to US letter size page
%  2.11 added header support for *u/*U compound paths
%  2.1  option of font outline instead of text(gwhite@trevnx.bio.dfo.ca)
%  2.0  major change to complex path handling
%  1.9  fixed text leaking ascii (,),\
%  1.85 added default font to handle no setfont (Courier)
%  1.84 added even-odd fill/clip (D)
%  1.83 undefined PPD PageSize printer specific info
%  1.82 added kludge to save clipping status through a restore
%  1.81 added custom color/gray support to header (x/X, g/G)
%  1.8  added newpath if clippath is not consumed correctly(amiga)
%  1.79 eliminated scientific notation of numbers less than 0.0001
%  1.78 fixed transposed h & H
%  1.77 made laserwriter 8 fixes optional
%  1.76 added margin fix for unix AI (brown@wi.extrel.com)
%  1.75 added kludge to handle bitmap font errors (TeX, Windows.ps)
%  1.74 made grestore a little smarter
%  1.73 included header handle encoded fontname (/_fontname)
%  1.72 fixed problem with restore/clip info - (not enough Qs problem)
%  1.71 filter font names to remove previous encoding (|,_,etc)
%  1.7  change text format to AI3, works better with PS & CD
%  1.67 deal with weird makefonts
%  1.66 handle to many bad stroke/fills (s s s w/o paths)
%  1.65 more useable with non-gs interpreters (defaultmatrix fix)
%  1.64 fixed "smart grestore" repeat bug
%  1.63 fixed ashow/awidthshow bug
%  1.62 check if cmykcolor is understood otherwise rgb
%  1.61 made grestore smarter (only print if different)
%  1.6  add better compatibility to CorelDraw and PhotoShop
%  1.53 make it more gs-backward compatible (clarke@lsl.co.uk)
%  1.52 handle clipping paths a little better (Posted)
%  1.51 improve mac lw8 output (lines instead of filled boxes)
%  1.5 handle some level 2 stuff (mac lw8)
%  1.4 fixed scaling of linewidth and dash
%  1.31 made trailer more AI88 friendly
%  1.3 add ablity to output to file directly
%  1.21 print matrix cleaner
%  1.2 fix rotated fonts, thanks to G.Cameron (g.cameron@biomed.abdn.ac.uk)
%  1.1 fix stroke/fill color difference (k vs K)
%  1.0 posted to comp.lang.postscript
%
%         - To Do List -
%  find real %%BoundingBox: llx lly urx ury
%  make MacGS friendly (line-endings)
%  handle eps w/o showpage:(append to end)
%  write out image data to external file
%
%xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
%                  Nothing of Interest below here
%xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
matrix identmatrix setmatrix %   make ctm [1 0 0 1 0 0]
/bdef {bind def} bind def
/oldgsave {} def /oldgrestore {} def
/initgraphics {} def /initmatrix {} def
% undefine PPD PageSizes to be more printer independant
/letter {} def /legal {} def /a4 {} def /b5 {} def /lettersmall {} def
/setpagedevice { pop } bdef % for level 2 PPD PageSizes
/Courier findfont 12 scalefont setfont % handle no setfont
/initclip {0 0 moveto 0 792 lineto 612 792 lineto 612 0 lineto closepath
           clip newpath } bdef
/xdef {exch def} bdef
/trx {transform exch} bdef
/cbdef {cvx bind def} bdef
/jltz {dup abs 0.0001 lt {pop 0} if} bdef % get rid of scientific notation bug
/clstate false def        % closepath state
/dpth false def           % destroy path (ie newpath)
/fclp false def           % first paint after clip
/kscl {1.0} def           % default current scale X-factor
/gcnt {1} def             % graphics state counter
/spth {1} def             % multiple paths on stack
/jeol (\n) def            % default end-of-line
/jnump {0} def            % number of paths on stack
/jx {0} def /jy {0} def /j_ax {0} def
/j3ftxt true def
/clarry 10 array def
0 1 9 {clarry exch false put} for % initilize no clipping path
%
% handle cmyk color on level 1 interpreters
/setcmykcolor where {pop}
 {/setcmykcolor {
   /blk exch def /yel exch def /mag exch def /cyan exch def
   /ccomp {add dup 1 gt {pop 1} if} def
   /red {1 cyan blk ccomp sub} def
   /green {1 mag blk ccomp sub} def
   /blue {1 yel blk ccomp sub} def
   red green blue setrgbcolor
  } bdef
} ifelse
/currentcmykcolor where {pop}
 {/currentcmykcolor {
   currentrgbcolor /bval xdef /gval xdef /rval xdef
   /rawC 1 rval sub def /rawM 1 gval sub def /rawY 1 bval sub def
   rawC rawM ge { rawY rawM ge { /blk rawM def} if } if
   rawC rawY ge { rawM rawY ge { /blk rawY def} if } if
   rawY rawC ge { rawM rawC ge { /blk rawC def} if } if
   rawY rawC eq { rawM rawC eq { /blk rawC def} if } if
   /cyan  rawC blk sub  def
   /mag  rawM blk sub  def
   /yel  rawY blk sub  def
   /blk blk def
   cyan mag yel blk
  } bdef
} ifelse
% If using Mac Ghostscript
jMacGS {
%        /jeol {(\r) jp} def
        /jout true def
        (%%Note: Loading ps2ai.ps\n) print
       } if
/jstr 40 string def
jout {joutput (w) file /joutput xdef} if
%
%              Output
%
jout {/jp { joutput exch writestring } bdef }{/jp {print} bdef} ifelse
/jpnum {jltz ( ) jp =string cvs jp } bdef
/jpmat { (\[) jp { jpnum } forall (\]) jp } bdef
%
%              Stack to Paths converters
%
/ckpnt { % check which paint and clipping to use
   dpth {  % if there are multiple paths on the stack
  clarry gcnt get fclp and {clstate {(h W\n) jp }{(H W\n) jp } ifelse} if
  spth 0 eq {clstate {(n\n) jp }{(N\n) jp } ifelse} if
  spth 1 eq {clstate {(s\n) jp }{(S\n) jp } ifelse} if
  spth 2 eq {clstate {(f\n) jp }{(F\n) jp } ifelse} if
     } if
} bdef
/jpm {
  ckpnt
  /dpth true def
  transform 2 copy /yst xdef /xst xdef exch jpnum jpnum ( m\n) jp } bdef
/jpl { trx jpnum jpnum ( l\n) jp } bdef
/jpc {  6 4 roll trx jpnum jpnum 4 2 roll trx jpnum jpnum trx
    jpnum jpnum ( c\n) jp } bdef
/jpp {xst jpnum yst jpnum ( l\n) jp /clstate true def} bdef
/cntpaths { % count paths on stack
  oldgsave
  {pop pop /jnump jnump 1 add def} {pop pop} {6 {pop} repeat}{} pathforall
  oldgrestore
} bdef
/ppforall {
 cntpaths % find out how many paths are on the stack
 jnump 1 gt { (*u\n) jp } if
 {jpm}{jpl}{jpc}{jpp} pathforall
  ckpnt
 jnump 1 gt { (*U\n) jp } if
 /jnump 0 def /clstate false def /dpth false def /fclp false def
  oldnewpath
} bdef
%
%              Painting Operators
%
/oldnewpath [/newpath load] cbdef
/newpath { (\n) jp /spth 0 def ppforall} bdef
/stroke { (\n) jp /spth 1 def ppforall } bdef
/fill   {(\n) jp /spth 2 def ppforall } bdef
/eofill {(1 D\n) jp fill (0 D\n) jp} bdef
/clip {clarry gcnt get {(Q\nq\n) jp}{(q\n) jp} ifelse
                   /fclp true def clarry gcnt true put} bdef
/eoclip {(1 D\n) jp clip (0 D\n) jp} bdef
%
%               Text Operators
%
/oldshow [/show load] cbdef
/curpt {stringwidth pop jx add jy} bdef
/jNN {dup 0 eq {pop oldgsave currentfont /FontMatrix get setmatrix kscl
                oldgrestore} if
} bdef
/curftmatrix {
 currentfont /FontMatrix get dup 0 get jNN abs /norm exch def
 dup 0 get norm div exch dup
 1 get norm div exch dup 2 get norm div exch dup 3 get norm div exch dup
 4 get exch 5 get 6 array astore matrix currentmatrix matrix concatmatrix
} bdef
% AI does not support negitive font sizes
/curftsize {currentfont /FontMatrix get 0 get jNN abs 1000 mul} bdef
/hstr (X) def
/vbar (|) 0 get def /undsc (_) 0 get def
/ftnamefix { % handle font names with |,_ (previously encoded)
jstr cvs
{ %forall
        dup vbar eq {pop}{ %ifelse
            dup undsc eq {pop}{ %ifelse
                    hstr exch 0 exch put hstr jp
            } ifelse
        } ifelse
   } forall   flush
} bdef
%/curftname {currentfont /FontName get ftnamefix} bdef
/curftname { currentfont /FontName known {currentfont /FontName get}
           { (Times-Roman)} ifelse ftnamefix } bdef
/lftpar (\() 0 get def
/rhtpar (\)) 0 get def
/bckslsh (\\) 0 get def
/handft { % handle strings with (,),\
   (\() jp
   { %forall
        dup lftpar eq { (\\\() jp }{ %ifelse
            dup rhtpar eq { (\\\)) jp }{ %ifelse
                dup bckslsh eq { (\\\\) jp }{ %ifelse
                    hstr exch 0 exch put hstr jp
                } ifelse
            } ifelse
        } ifelse
   } forall (\)) jp flush
} bdef
% AI 3 text format pieces
jtxt3 {
/j3txt { j3ftxt {(0 Ts 100 Tz 0 Tt 0 TA 0 0 5 TC 100 100 200 TW 0 0 0 Ti\n) jp
                (0 Ta 0 Tq 0 0 TI 0 Tc 0 Tw\n) jp} if } bdef
/show {oldgsave  (0 To\n) jp
  currentpoint 2 copy /jy exch def /jx exch def translate
  curftmatrix /jitm exch def
  0 1 5 {jitm exch get jpnum} for ( 0 Tp\n) jp (TP\n) jp
  (0 Tr\n) jp (\/_) jp curftname  curftsize jpnum ( Tf\n) jp
  (0) jp j_ax  curftsize div 100 mul jpnum ( 100 TC\n) jp %  percent(?)
  dup curpt moveto mark exch handft ( Tx\n) jp (TO\n) jp /j3ftxt false def
  cleartomark currentpoint oldgrestore moveto
} bdef
/ashow {exch pop exch /j_ax exch def show /j_ax {0} def } bdef
}
 {
/show {oldgsave (u\n) jp currentpoint 2 copy /jy exch def /jx exch def translate
  (\/) jp curftname jstr cvs jp
  curftsize dup jpnum  jpnum ( 0 0 z\n) jp
  curftmatrix jpmat ( e\n) jp
  dup curpt moveto mark exch handft ( t T U\n) jp
  cleartomark currentpoint oldgrestore moveto} bdef
/ashow {oldgsave (u\n) jp currentpoint translate (\/) jp curftname jstr cvs jp
  curftsize dup jpnum jpnum  exch kscl mul jpnum ( 0 z\n) jp
  curftmatrix jpmat ( e\n) jp dup curpt moveto mark exch handft
  ( t T U\n) jp cleartomark currentpoint oldgrestore moveto} bdef
} ifelse
/widthshow { show pop pop pop} bdef
/awidthshow {ashow pop pop pop} bdef
/kshow {show pop} bdef
%/show {true charpath fill} bdef   % get outline of charactor
joutln {/show { true charpath currentpoint
     /jy exch def /jx exch def fill jx jy moveto} bdef} if
%/show {oldshow} bdef    % do nothing different
%
%               Color Operators
%
/oldsetcmykcolor [/setcmykcolor load] cbdef
/setcmykcolor {oldsetcmykcolor
currentcmykcolor 4 -1 roll jpnum 3 -1 roll jpnum 2 -1 roll jpnum jpnum ( k\n) jp
currentcmykcolor 4 -1 roll jpnum 3 -1 roll jpnum 2 -1 roll jpnum jpnum ( K\n) jp
 } bdef
/oldsetgray [/setgray load] cbdef
/setgray {0 0 0 4 -1 roll 1 exch sub setcmykcolor} bdef
/oldsethsbcolor [/sethsbcolor load] cbdef
/sethsbcolor {oldsethsbcolor currentcmykcolor setcmykcolor} bdef
/oldsetrgbcolor [/setrgbcolor load] cbdef
/setrgbcolor {oldsetrgbcolor currentrgbcolor /bval xdef /gval xdef /rval xdef
 /rawC 1 rval sub def /rawM 1 gval sub def /rawY 1 bval sub def
 rawC rawM ge { rawY rawM ge { /blk rawM def} if } if
 rawC rawY ge { rawM rawY ge { /blk rawY def} if } if
 rawY rawC ge { rawM rawC ge { /blk rawC def} if } if
 rawY rawC eq { rawM rawC eq { /blk rawC def} if } if
 /cyan  rawC blk sub  def
 /mag  rawM blk sub  def
 /yel  rawY blk sub  def
 /blk blk def
 cyan mag yel blk setcmykcolor } bdef
%
%                State Operators
%
/oldsetlinewidth [/setlinewidth load] cbdef
/setlinewidth {kscl abs mul jltz  oldsetlinewidth
 currentlinewidth jpnum ( w\n) jp } bdef
/oldsetlinecap [/setlinecap load] cbdef
/setlinecap {dup oldsetlinecap jpnum ( J\n) jp} bdef
/oldsetlinejoin [/setlinejoin load] cbdef
/setlinejoin {dup oldsetlinejoin jpnum ( j\n) jp} bdef
/oldsetmiterlimit [/setmiterlimit load] cbdef
/setmiterlimit {dup oldsetmiterlimit jpnum ( M\n) jp}bdef
/oldsetdash [/setdash load] cbdef
/setdash {exch [ exch {kscl abs mul} forall ] exch kscl abs mul oldsetdash
  currentdash exch jpmat jpnum ( d\n) jp } bdef
/oldsetflat [/setflat load] cbdef
/setflat {dup oldsetflat jpnum ( i\n) jp } bdef
%
%                More State Operators
%
/kscl { % use just the x scale factor
 oldgsave
 matrix currentmatrix /jctm exch def
 jctm 4 0 put jctm 5 0 put jctm setmatrix
 1 0 moveto currentpoint transform
 dup mul exch dup mul add sqrt 10000 mul round 10000 div
 oldgrestore
} bdef
/currentstate {currentcmykcolor setcmykcolor
 currentflat jpnum ( i) jp currentlinecap jpnum ( J) jp
 currentlinejoin jpnum ( j) jp currentlinewidth jpnum ( w) jp
 currentmiterlimit jpnum ( M ) jp currentdash exch jpmat jpnum ( d\n) jp
} bdef
/jdifG {
 currentcmykcolor /jok xdef /joy xdef /jom xdef /joc xdef
 currentflat /jof xdef currentlinecap /jolc xdef currentlinejoin /jolj xdef
 currentlinewidth /jolw xdef currentmiterlimit /joml xdef
 currentdash /jood xdef /joad xdef
 oldgrestore
 currentcmykcolor /jnk xdef /jny xdef /jnm xdef /jnc xdef
 currentflat /jnf xdef currentlinecap /jnlc xdef currentlinejoin /jnlj xdef
 currentlinewidth /jnlw xdef currentmiterlimit /jnml xdef
 currentdash /jnod xdef /jnad xdef
 % compare old gstate to new gstate
 joc jnc ne jom jnm ne joy jny ne jok jnk ne
 jof jnf ne jolc jnlc ne jolj jnlj ne jolw jnlw ne joml jnml ne
 false joad {true exit} forall {pop pop true}{false} ifelse
 false jnad {true exit} forall {pop pop true}{false} ifelse ne
 jood jnod ne 10 {or} repeat {currentstate} if
} bdef
/oldgsave [/gsave load] cbdef
/gsave {oldgsave /gcnt gcnt 1 add def } bdef % clarry gcnt false put} bdef
%  (%%Note:gsave ) jp gcnt jpnum (\n) jp} bdef
/oldgrestore [/grestore load] cbdef
/grestore {dpth {newpath} if clarry gcnt get {(Q\n) jp clarry gcnt false put} if
 jdifG /gcnt gcnt 1 sub def } bdef
% oldgrestore currentstate } bdef
% (%%Note:grestore ) jp gcnt 1 add jpnum (\n) jp} bdef
/oldrestore [/restore load] cbdef
% a kludgy way of saving the clipping path status information
/restore {clarry aload pop 11 -1 roll oldrestore clarry astore pop} bdef
/showpage {  0 1 9 {clarry exch get {(Q\n) jp} if } for
 (%%Note: If Error, make sure there are matched pairs of 'q's and 'Q's\n) jp
 (%%Note: in the file. Add 'Q's before '%%Trailer' until equal\n) jp
 (%%Trailer\n) jp
 jtxt3 {(Adobe_IllustratorA_AI3 /terminate get exec\n) jp
        (Adobe_typography_AI3 /terminate get exec\n) jp
        (Adobe_customcolor /terminate get exec\n) jp
        (Adobe_cshow /terminate get exec\n) jp
        (Adobe_cmykcolor /terminate get exec\n) jp
        (Adobe_packedarray /terminate get exec\n) jp
}{
        (Adobe_Illustrator881 /terminate get exec\n) jp
        (Adobe_customcolor /terminate get exec\n) jp
        (Adobe_cshow /terminate get exec\n) jp
        (Adobe_cmykcolor /terminate get exec\n) jp
        (Adobe_packedarray /terminate get exec\n) jp
       } ifelse
( showpage\n%EOF\n%%EndDocument\n) jp
 jout {joutput closefile} if jMacGS not {quit} if /j3ftxt true def } bdef
%
%                Error handling
%
errordict begin
% Attempt to handle the error caused by bitmap fonts (TeX,Windows.ps,etc)
% this is a big-time kludge
jbiterr {
 /undefined {pop pop (Times-Roman)} bdef
 /typecheck {pop pop} bdef
} if
jerr {
 /handleerror {
  (%%Note: ps2ai error, aborting rest of conversion\n) jp showpage
 } bdef
} if
end
%
%                Mac LW 8 improvements
%
/jmacimp { % stroked line instead of thin filled boxes
 /@a {  3 -1 roll 2 div dup 3 -1 roll add exch 3 -1 roll add exch moveto
      3 -1 roll 2 div dup 3 -1 roll add exch 3 -1 roll exch sub exch lineto
      abs setlinewidth  stroke pop pop} bdef
 /@b { 3 -1 roll 2 div dup 3 -1 roll add exch 3 -1 roll add exch moveto
      pop
      3 -1 roll 2 div dup 3 -1 roll add exch 3 -1 roll add exch lineto
      abs setlinewidth  stroke} bdef
 /endp {showpage pm restore} bdef % because the restore stops clean up
} bdef
%
%                Handle (some) PS Level 2
%
/rectstroke { 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto neg 0 rlineto
  closepath stroke} bdef
/rectfill { 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto neg 0 rlineto
  fill } bdef
/rectclip { 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto neg 0 rlineto
  closepath clip newpath jMacfix {jmacimp} if } bdef
%
% Add a header prolog to the output file so it is still view/print-able
%
(%!PS-Adobe-2.0 EPSF-1.2\n%%BoundingBox: 0 0 612 792\n) jp
(%%Title: Adobe Illustator 3 Editable Document\n) jp
(%%Creator: ps2ai.ps vers.) jp vers jpnum ( \(C\) 1993-94 Jason Olszewski\n) jp
(%%TemplateBox: 0 0 612 792\n) jp
jtxt3 {(%%AI3_Margin:0 0 0 0\n) jp } if
(%%EndComments\n) jp
(%%BeginProlog\n) jp
(/m {moveto} def /l {lineto} def /c {curveto} def\n) jp
(/S {stroke} def /F {fill} def\n) jp
(/s {closepath S} def /f {closepath F} def\n) jp
(/q {gsave} def /Q {grestore} def /W {clip} def /k {setcmykcolor} def\n) jp
(/i {setflat} def /J {setlinecap} def /j {setlinejoin} def\n) jp
(/w {setlinewidth} def /M {setmiterlimit} def /d {setdash} def\n) jp
(/u {gsave} def /U {grestore} def /K {k} def\n) jp
(/N {newpath} def /n {closepath N} def\n) jp
(/g {setgray} def /G {g} def\n) jp
(/x {pop pop k} def /X {x} def\n) jp
(/H {} def /h {H closepath} def /D {pop} def\n) jp
(/*u { /N {/spth 0 def}def /S{/spth 1 def}def /F {/spth 2 def} def} def\n) jp
(/*U { spth 0 eq {newpath} if spth 1 eq {stroke} if spth 2 eq {fill} if\n) jp
(     /N {newpath} def /S {stroke} def /F {fill} def  } def\n) jp
%(\n) jp
jtxt3 {
 (/TC {pop pop pop} def /Tr {pop} def\n) jp
 (/To {pop gsave} def /TO {grestore} def\n) jp
 (/Tp {pop matrix astore concat} def  /TP {0 0 moveto} def\n) jp
 (/a_str 40 string def /cnt 0 def /h_str (X) def /undsc (_) 0 get def\n) jp
 (/fntfix {a_str cvs dup length 1 sub /f_str exch string def\n) jp
 (  {dup undsc eq {pop}{f_str cnt 3 -1 roll put /cnt cnt 1 add def\n) jp
 (  } ifelse } forall flush /cnt 0 def f_str cvn } bind def\n) jp

 (/Tf {exch fntfix findfont exch scalefont setfont} def /Tx {show} def\n) jp
}{
 (/z {pop pop pop exch findfont exch scalefont setfont} def\n) jp
 (/e {concat 0 0 m} def /t {show} def /T {} def\n) jp
} ifelse
(\n) jp
jtxt3 {
 (userdict /Adobe_packedarray 2 dict dup begin put\n) jp
 (/initialize {} def /terminate {} def\n) jp
 (userdict /Adobe_cmykcolor 2 dict dup begin put\n) jp
 (/initialize {} def /terminate {} def\n) jp
 (userdict /Adobe_cshow 2 dict dup begin put\n) jp
 (/initialize {} def /terminate {} def\n) jp
 (userdict /Adobe_customcolor 2 dict dup begin put\n) jp
 (/initialize {} def /terminate {} def\n) jp
 (userdict /Adobe_typography_AI3 2 dict dup begin put\n) jp
 (/initialize {} def /terminate {} def\n) jp
 (userdict /Adobe_IllustratorA_AI3 2 dict dup begin put\n) jp
 (/initialize {} def /terminate {} def\n) jp
}{
 (userdict /Adobe_packedarray 2 dict dup begin put\n) jp
 (/initialize {} def /terminate {} def\n) jp
 (userdict /Adobe_cmykcolor 2 dict dup begin put\n) jp
 (/initialize {} def /terminate {} def\n) jp
 (userdict /Adobe_cshow 2 dict dup begin put\n) jp
 (/initialize {} def /terminate {} def\n) jp
 (userdict /Adobe_customcolor 2 dict dup begin put\n) jp
 (/initialize {} def /terminate {} def\n) jp
 (userdict /Adobe_Illustrator881 2 dict dup begin put\n) jp
 (/initialize {} def /terminate {} def\n) jp
} ifelse
(%%EndProlog\n) jp
(%%BeginSetup\n) jp
jtxt3 {
 (Adobe_packedarray /initialize get exec\n) jp
 (Adobe_cmykcolor /initialize get exec\n) jp
 (Adobe_cshow /initialize get exec\n) jp
 (Adobe_customcolor /initialize get exec\n) jp
 (Adobe_typography_AI3 /initialize get exec\n) jp
 (Adobe_IllustratorA_AI3 /initialize get exec\n) jp
}{
 (Adobe_packedarray /initialize get exec\n) jp
 (Adobe_cmykcolor /initialize get exec\n) jp
 (Adobe_cshow /initialize get exec\n) jp
 (Adobe_customcolor /initialize get exec\n) jp
 (Adobe_Illustrator881 /initialize get exec\n) jp
} ifelse
(%%EndSetup\n) jp
0 0 0 1 oldsetcmykcolor
currentstate

jout {(%%Note: Load Postscript file to be converted now\n) print} if
